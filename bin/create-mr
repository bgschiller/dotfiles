#!/usr/bin/env bash
set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
log_info() { echo -e "${GREEN}[INFO]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1" >&2; }

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  log_error "Not in a git repository"
  exit 1
fi

# Check required tools
for tool in git glab claude jq; do
  if ! command -v "$tool" &>/dev/null; then
    log_error "$tool is not installed or not in PATH"
    exit 1
  fi
done

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UPDATE_MR_DESCRIPTION="$SCRIPT_DIR/update-mr-description"

if [ ! -x "$UPDATE_MR_DESCRIPTION" ]; then
  log_error "update-mr-description not found at $UPDATE_MR_DESCRIPTION"
  exit 1
fi

# Get current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
log_info "Current branch: $CURRENT_BRANCH"

# Check if branch is already pushed
if ! git rev-parse --verify "origin/$CURRENT_BRANCH" &>/dev/null; then
  log_step "Pushing branch to remote..."
  git push -u origin "$CURRENT_BRANCH"
fi

# Get target branch using git merge-target
log_step "Determining target branch..."
TARGET_BRANCH=$(git merge-target 2>/dev/null || echo "main")
if [ -z "$TARGET_BRANCH" ]; then
  TARGET_BRANCH="main"
fi
log_info "Target branch: $TARGET_BRANCH"

# Get commit messages for title generation
COMMITS=$(git log --pretty=format:"- %s" "origin/$TARGET_BRANCH".."$CURRENT_BRANCH" 2>/dev/null || git log --pretty=format:"- %s" -1)

# Generate title using Claude
log_step "Generating MR title..."
TITLE_PROMPT="Based on these commit messages, generate a concise, clear merge request title (max 80 characters).
Use imperative mood (e.g., 'Add feature' not 'Added feature').
Output ONLY the title, no quotes, no explanation.

Commits:
$COMMITS"

TITLE=$(echo "$TITLE_PROMPT" | claude --print 2>/dev/null)
if [ -z "$TITLE" ]; then
  log_error "Failed to generate title"
  exit 1
fi
log_info "Generated title: $TITLE"

# Generate description using update-mr-description
log_step "Generating MR description..."
DESCRIPTION=$("$UPDATE_MR_DESCRIPTION" --print-only "$CURRENT_BRANCH")
DESCRIPTION_EXIT_CODE=$?
if [ $DESCRIPTION_EXIT_CODE -ne 0 ]; then
  log_error "update-mr-description failed with exit code $DESCRIPTION_EXIT_CODE"
  exit 1
fi
if [ -z "$DESCRIPTION" ]; then
  log_error "Failed to generate description (empty output)"
  exit 1
fi
log_info "Generated description (${#DESCRIPTION} characters)"

# Create the merge request
log_step "Creating merge request..."
log_info "Running: glab mr create --title \"$TITLE\" --description <description> --target-branch \"$TARGET_BRANCH\" --yes"
MR_OUTPUT=$(glab mr create \
  --title "$TITLE" \
  --description "$DESCRIPTION" \
  --target-branch "$TARGET_BRANCH" \
  --yes 2>&1)
MR_EXIT_CODE=$?

if [ $MR_EXIT_CODE -ne 0 ]; then
  log_error "glab mr create failed with exit code $MR_EXIT_CODE"
  log_error "Output:"
  echo "$MR_OUTPUT" >&2
  exit 1
fi

# Extract MR number from output
log_info "Parsing glab output..."
MR_URL=$(echo "$MR_OUTPUT" | grep -oE 'https://[^ ]+' | head -1)
MR_NUMBER=$(echo "$MR_URL" | grep -oE '[0-9]+$')

if [ -z "$MR_NUMBER" ]; then
  log_error "Failed to extract MR number from output"
  log_error "Full glab output:"
  echo "$MR_OUTPUT" >&2
  log_error "Extracted URL: '$MR_URL'"
  exit 1
fi

log_info "Created MR !$MR_NUMBER: $MR_URL"

# Get GitLab host and project from origin URL
ORIGIN_URL=$(git remote get-url origin)
GITLAB_HOST="gitlab.grammarly.io"
if [[ "$ORIGIN_URL" =~ gitlab\.([^:]+) ]]; then
  GITLAB_HOST="gitlab.${BASH_REMATCH[1]}"
fi

# Get project path
PROJECT_PATH=$(glab repo view --output json 2>/dev/null | jq -r .path_with_namespace)
if [ -z "$PROJECT_PATH" ]; then
  log_error "Failed to get project path"
  exit 1
fi

# Get project ID
PROJECT_ID=$(glab repo view --output json 2>/dev/null | jq -r .id)
if [ -z "$PROJECT_ID" ]; then
  log_error "Failed to get project ID"
  exit 1
fi

# If target branch is not main, create dependency on parent MR
if [ "$TARGET_BRANCH" != "main" ]; then
  log_step "Looking for parent MR (source branch: $TARGET_BRANCH)..."
  log_info "Project ID: $PROJECT_ID"
  log_info "API query: projects/$PROJECT_ID/merge_requests?source_branch=$TARGET_BRANCH&state=opened"

  # Find MR where source branch is our target branch
  set +e
  PARENT_MR_DATA=$(glab api "projects/$PROJECT_ID/merge_requests?source_branch=$TARGET_BRANCH&state=opened" 2>&1)
  PARENT_MR_EXIT_CODE=$?
  set -e

  log_info "API response exit code: $PARENT_MR_EXIT_CODE"
  log_info "API response: $PARENT_MR_DATA"

  PARENT_MR_FIRST=$(echo "$PARENT_MR_DATA" | jq '.[0]' 2>/dev/null || echo "null")

  if [ "$PARENT_MR_FIRST" != "null" ] && [ -n "$PARENT_MR_FIRST" ]; then
    PARENT_MR_IID=$(echo "$PARENT_MR_FIRST" | jq -r .iid)
    PARENT_MR_ID=$(echo "$PARENT_MR_FIRST" | jq -r .id)
    log_info "Found parent MR !$PARENT_MR_IID (ID: $PARENT_MR_ID)"

    log_step "Creating MR dependency..."
    log_info "API call: POST projects/$PROJECT_ID/merge_requests/$MR_NUMBER/blocks?blocking_merge_request_id=$PARENT_MR_ID"

    # Create blocking relationship: parent MR blocks this MR
    # Note: blocking_merge_request_id must be the global ID (not IID) and a query parameter
    set +e
    BLOCK_RESPONSE=$(glab api -X POST "projects/$PROJECT_ID/merge_requests/$MR_NUMBER/blocks?blocking_merge_request_id=$PARENT_MR_ID" 2>&1)
    BLOCK_EXIT_CODE=$?
    set -e

    log_info "Block API exit code: $BLOCK_EXIT_CODE"
    log_info "Block API response (truncated): $(echo "$BLOCK_RESPONSE" | head -c 200)..."

    if [ $BLOCK_EXIT_CODE -eq 0 ]; then
      log_info "Successfully created dependency: !$PARENT_MR_IID blocks !$MR_NUMBER"
    else
      log_warn "Failed to create MR dependency"
      log_warn "Exit code: $BLOCK_EXIT_CODE"
      log_warn "Response: $BLOCK_RESPONSE"
    fi
  else
    log_warn "No parent MR found with source branch '$TARGET_BRANCH'"
    log_warn "Parsed first MR: $PARENT_MR_FIRST"
  fi
fi

# Generate Slack message
log_step "Generating Slack review request..."
echo ""
echo "=== Slack Message ==="
echo "Please review my MR [$TITLE]($MR_URL)"
echo "===================="
echo ""

log_info "Done! MR created successfully."
