#!/usr/bin/env bash
set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
log_info() { echo -e "${GREEN}[INFO]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1" >&2; }

log_step "Starting create-mr script..."
log_info "Working directory: $(pwd)"

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  log_error "Not in a git repository"
  exit 1
fi

# Check required tools
for tool in git glab claude jq; do
  if ! command -v "$tool" &>/dev/null; then
    log_error "$tool is not installed or not in PATH"
    exit 1
  fi
done

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UPDATE_MR_DESCRIPTION="$SCRIPT_DIR/update-mr-description"

if [ ! -x "$UPDATE_MR_DESCRIPTION" ]; then
  log_error "update-mr-description not found at $UPDATE_MR_DESCRIPTION"
  exit 1
fi

# Get current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
log_info "Current branch: $CURRENT_BRANCH"

# Check if branch is already pushed
log_step "Checking if branch is already pushed..."
if ! git rev-parse --verify "origin/$CURRENT_BRANCH" &>/dev/null; then
  log_step "Pushing branch to remote..."
  if git push -u origin "$CURRENT_BRANCH"; then
    log_info "Branch pushed successfully"
  else
    log_error "Failed to push branch"
    exit 1
  fi
else
  log_info "Branch already exists on remote"
fi

# Get target branch using git merge-target
log_step "Determining target branch..."
TARGET_BRANCH=$(git merge-target 2>/dev/null || echo "main")
if [ -z "$TARGET_BRANCH" ]; then
  TARGET_BRANCH="main"
fi
log_info "Target branch: $TARGET_BRANCH"

# Generate title and description using update-mr-description
log_step "Generating MR title and description..."
log_info "Running: $UPDATE_MR_DESCRIPTION --print-only $CURRENT_BRANCH"
MR_CONTENT=$("$UPDATE_MR_DESCRIPTION" --print-only "$CURRENT_BRANCH")
MR_CONTENT_EXIT_CODE=$?
log_info "update-mr-description exit code: $MR_CONTENT_EXIT_CODE"

if [ $MR_CONTENT_EXIT_CODE -ne 0 ]; then
  log_error "update-mr-description failed with exit code $MR_CONTENT_EXIT_CODE"
  log_error "Output: ${MR_CONTENT:0:500}"
  exit 1
fi
if [ -z "$MR_CONTENT" ]; then
  log_error "Failed to generate MR content (empty output)"
  exit 1
fi

# Parse the output to extract title and description
# Expected format: # Title\n\nDescription OR Title (first line)\n\nDescription
log_step "Parsing title and description..."

# Extract title - try two formats:
# 1. First line that starts with # (markdown heading)
TITLE=$(echo "$MR_CONTENT" | grep -m 1 "^# " | sed 's/^# //')

# 2. If no markdown heading found, use first non-empty line as title
if [ -z "$TITLE" ]; then
  TITLE=$(echo "$MR_CONTENT" | head -1 | sed 's/^[[:space:]]*//')
  if [ -z "$TITLE" ]; then
    log_error "Failed to parse title from output"
    log_error "Output: ${MR_CONTENT:0:500}"
    exit 1
  fi
  log_info "Using first line as title (no # found)"

  # If we used first line as title, description is everything after first line
  DESCRIPTION=$(echo "$MR_CONTENT" | tail -n +2 | sed '/./,$!d')
else
  log_info "Found markdown heading for title"

  # If we found a # heading, description is everything after that line
  # Find line number of the heading and extract everything after it
  HEADING_LINE_NUM=$(echo "$MR_CONTENT" | grep -n "^# " | head -1 | cut -d: -f1)
  DESCRIPTION=$(echo "$MR_CONTENT" | tail -n +$((HEADING_LINE_NUM + 1)) | sed '/./,$!d')
fi

log_info "Parsed title: $TITLE"

if [ -z "$DESCRIPTION" ]; then
  log_error "Failed to parse description from output"
  exit 1
fi
log_info "Parsed description (${#DESCRIPTION} characters)"
log_info "First 200 chars: ${DESCRIPTION:0:200}"

# Write title and description to temp file and open in editor for approval
log_step "Creating temp file for MR content..."
DESCRIPTION_FILE=$(mktemp "/tmp/mr-description-XXXXXX.md")
log_info "Temp file: $DESCRIPTION_FILE"

echo "// MR Title and Description" >"$DESCRIPTION_FILE"
echo "// Edit before submitting" >>"$DESCRIPTION_FILE"
echo "// Any lines starting with // will be ignored" >>"$DESCRIPTION_FILE"
echo "// To cancel, delete the contents of the file and save and quit" >>"$DESCRIPTION_FILE"
echo "" >>"$DESCRIPTION_FILE"
echo "# $TITLE" >>"$DESCRIPTION_FILE"
echo "" >>"$DESCRIPTION_FILE"
echo "$DESCRIPTION" >>"$DESCRIPTION_FILE"

log_info "Wrote title and description to temp file"
log_step "Opening MR content in \$EDITOR for approval..."
log_info "EDITOR=${EDITOR:-vi}"
"${EDITOR:-vi}" "$DESCRIPTION_FILE"
log_info "Editor closed"

# Read back the edited content and filter out comment lines
EDITOR_OUTPUT=$(grep -v "^//" "$DESCRIPTION_FILE" || true)
if [ -z "$EDITOR_OUTPUT" ]; then
  log_warn "MR creation cancelled due to empty file"
  rm -f "$DESCRIPTION_FILE"
  exit 1
fi

log_info "Content approved"

# Re-parse title and description from edited content
TITLE=$(echo "$EDITOR_OUTPUT" | grep -m 1 "^# " | sed 's/^# //')
# If no markdown heading found, use first non-empty line as title
if [ -z "$TITLE" ]; then
  TITLE=$(echo "$EDITOR_OUTPUT" | head -1 | sed 's/^[[:space:]]*//')
fi
DESCRIPTION=$(echo "$EDITOR_OUTPUT" | tail -n +2 | sed '/./,$!d')

if [ -z "$TITLE" ]; then
  log_error "Title is empty after editing"
  rm -f "$DESCRIPTION_FILE"
  exit 1
fi
log_info "Final title: $TITLE"
log_info "Final description length: ${#DESCRIPTION} characters"

# Clean up temp file
rm -f "$DESCRIPTION_FILE"

# Create the merge request
log_step "Creating merge request..."
log_info "Running: glab mr create --title \"$TITLE\" --description <description> --target-branch \"$TARGET_BRANCH\" --yes"
MR_OUTPUT=$(glab mr create \
  --title "$TITLE" \
  --description "$DESCRIPTION" \
  --target-branch "$TARGET_BRANCH" \
  --remove-source-branch \
  --yes 2>&1)
MR_EXIT_CODE=$?

if [ $MR_EXIT_CODE -ne 0 ]; then
  log_error "glab mr create failed with exit code $MR_EXIT_CODE"
  log_error "Output:"
  echo "$MR_OUTPUT" >&2
  exit 1
fi

# Extract MR number from output
log_info "Parsing glab output..."
MR_URL=$(echo "$MR_OUTPUT" | grep -oE 'https://[^ ]+' | head -1)
MR_NUMBER=$(echo "$MR_URL" | grep -oE '[0-9]+$')

if [ -z "$MR_NUMBER" ]; then
  log_error "Failed to extract MR number from output"
  log_error "Full glab output:"
  echo "$MR_OUTPUT" >&2
  log_error "Extracted URL: '$MR_URL'"
  exit 1
fi

log_info "Created MR !$MR_NUMBER: $MR_URL"

# Get GitLab host and project from origin URL
ORIGIN_URL=$(git remote get-url origin)
GITLAB_HOST="gitlab.grammarly.io"
if [[ "$ORIGIN_URL" =~ gitlab\.([^:]+) ]]; then
  GITLAB_HOST="gitlab.${BASH_REMATCH[1]}"
fi

# Get project path
PROJECT_PATH=$(glab repo view --output json 2>/dev/null | jq -r .path_with_namespace)
if [ -z "$PROJECT_PATH" ]; then
  log_error "Failed to get project path"
  exit 1
fi

# Get project ID
PROJECT_ID=$(glab repo view --output json 2>/dev/null | jq -r .id)
if [ -z "$PROJECT_ID" ]; then
  log_error "Failed to get project ID"
  exit 1
fi

# If target branch is not main, create dependency on parent MR
if [ "$TARGET_BRANCH" != "main" ]; then
  log_step "Looking for parent MR (source branch: $TARGET_BRANCH)..."
  log_info "Project ID: $PROJECT_ID"
  log_info "API query: projects/$PROJECT_ID/merge_requests?source_branch=$TARGET_BRANCH&state=opened"

  # Find MR where source branch is our target branch
  set +e
  PARENT_MR_DATA=$(glab api "projects/$PROJECT_ID/merge_requests?source_branch=$TARGET_BRANCH&state=opened" 2>&1)
  PARENT_MR_EXIT_CODE=$?
  set -e

  log_info "API response exit code: $PARENT_MR_EXIT_CODE"
  log_info "API response: $PARENT_MR_DATA"

  PARENT_MR_FIRST=$(echo "$PARENT_MR_DATA" | jq '.[0]' 2>/dev/null || echo "null")

  if [ "$PARENT_MR_FIRST" != "null" ] && [ -n "$PARENT_MR_FIRST" ]; then
    PARENT_MR_IID=$(echo "$PARENT_MR_FIRST" | jq -r .iid)
    PARENT_MR_ID=$(echo "$PARENT_MR_FIRST" | jq -r .id)
    log_info "Found parent MR !$PARENT_MR_IID (ID: $PARENT_MR_ID)"

    log_step "Creating MR dependency..."
    log_info "API call: POST projects/$PROJECT_ID/merge_requests/$MR_NUMBER/blocks?blocking_merge_request_id=$PARENT_MR_ID"

    # Create blocking relationship: parent MR blocks this MR
    # Note: blocking_merge_request_id must be the global ID (not IID) and a query parameter
    set +e
    BLOCK_RESPONSE=$(glab api -X POST "projects/$PROJECT_ID/merge_requests/$MR_NUMBER/blocks?blocking_merge_request_id=$PARENT_MR_ID" 2>&1)
    BLOCK_EXIT_CODE=$?
    set -e

    log_info "Block API exit code: $BLOCK_EXIT_CODE"
    log_info "Block API response (truncated): $(echo "$BLOCK_RESPONSE" | head -c 200)..."

    if [ $BLOCK_EXIT_CODE -eq 0 ]; then
      log_info "Successfully created dependency: !$PARENT_MR_IID blocks !$MR_NUMBER"
    else
      log_warn "Failed to create MR dependency"
      log_warn "Exit code: $BLOCK_EXIT_CODE"
      log_warn "Response: $BLOCK_RESPONSE"
    fi
  else
    log_warn "No parent MR found with source branch '$TARGET_BRANCH'"
    log_warn "Parsed first MR: $PARENT_MR_FIRST"
  fi
fi

# Generate Slack message
log_step "Generating Slack review request..."
echo ""
echo "=== Slack Message ==="
echo "Please review my MR to [$TITLE]($MR_URL)"
echo "===================="
echo ""

log_info "Done! MR created successfully."
