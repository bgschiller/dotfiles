#!/usr/bin/env bash
set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
log_info() { echo -e "${GREEN}[INFO]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_step() { echo -e "${BLUE}[STEP]${NC} $1" >&2; }

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NOTIFY_SCRIPT="$SCRIPT_DIR/notify"
SFX_SCRIPT="$SCRIPT_DIR/sfx"

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  log_error "Not in a git repository"
  exit 1
fi

# Check required tools
for tool in git glab jq; do
  if ! command -v "$tool" &>/dev/null; then
    log_error "$tool is not installed or not in PATH"
    exit 1
  fi
done

if [ ! -x "$NOTIFY_SCRIPT" ]; then
  log_error "notify script not found at $NOTIFY_SCRIPT"
  exit 1
fi

if [ ! -x "$SFX_SCRIPT" ]; then
  log_error "sfx script not found at $SFX_SCRIPT"
  exit 1
fi

# Get current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
log_info "Current branch: $CURRENT_BRANCH"

# Get project path from glab
PROJECT_PATH=$(glab repo view --output json 2>/dev/null | jq -r .path_with_namespace)
if [ -z "$PROJECT_PATH" ]; then
  log_error "Failed to get project path"
  exit 1
fi
log_info "Project: $PROJECT_PATH"

# Get project ID
PROJECT_ID=$(glab repo view --output json 2>/dev/null | jq -r .id)
if [ -z "$PROJECT_ID" ]; then
  log_error "Failed to get project ID"
  exit 1
fi

# Get the latest pipeline for this branch
log_step "Fetching latest pipeline for branch $CURRENT_BRANCH..."
# Fetch more pipelines to filter out external (Semgrep) pipelines
PIPELINE_DATA=$(glab api "projects/$PROJECT_ID/pipelines?ref=$CURRENT_BRANCH&per_page=5" 2>&1)

if [ -z "$PIPELINE_DATA" ] || [ "$PIPELINE_DATA" == "[]" ]; then
  log_error "No pipeline found for branch $CURRENT_BRANCH"
  exit 1
fi

# Filter out external pipelines (like Semgrep) and get the first real CI pipeline
FILTERED_PIPELINE=$(echo "$PIPELINE_DATA" | jq '[.[] | select(.source != "external")] | .[0]')

if [ -z "$FILTERED_PIPELINE" ] || [ "$FILTERED_PIPELINE" == "null" ]; then
  log_error "No non-external pipeline found for branch $CURRENT_BRANCH"
  exit 1
fi

PIPELINE_ID=$(echo "$FILTERED_PIPELINE" | jq -r '.id')
PIPELINE_STATUS=$(echo "$FILTERED_PIPELINE" | jq -r '.status')
PIPELINE_WEB_URL=$(echo "$FILTERED_PIPELINE" | jq -r '.web_url')

if [ -z "$PIPELINE_ID" ] || [ "$PIPELINE_ID" == "null" ]; then
  log_error "Failed to parse pipeline data"
  exit 1
fi

log_info "Pipeline ID: $PIPELINE_ID"
log_info "Current status: $PIPELINE_STATUS"
log_info "URL: $PIPELINE_WEB_URL"

# Poll interval in seconds
POLL_INTERVAL=10

# Terminal states
TERMINAL_STATES=("success" "failed" "canceled" "skipped")

# Function to check if status is terminal
is_terminal_status() {
  local status=$1
  for terminal in "${TERMINAL_STATES[@]}"; do
    if [ "$status" == "$terminal" ]; then
      return 0
    fi
  done
  return 1
}

# Function to send notification and play sound
send_notification() {
  local title=$1
  local message=$2
  local sound=$3

  "$NOTIFY_SCRIPT" "$title" "$message"
  "$SFX_SCRIPT" "$sound"
}

# If already in terminal state, notify and exit
if is_terminal_status "$PIPELINE_STATUS"; then
  log_info "Pipeline is already in terminal state: $PIPELINE_STATUS"

  if [ "$PIPELINE_STATUS" == "success" ]; then
    send_notification "✅ Pipeline Succeeded" "$CURRENT_BRANCH" "good"
    log_info "Pipeline succeeded!"
  else
    send_notification "❌ Pipeline $PIPELINE_STATUS" "$CURRENT_BRANCH" "bad"
    log_error "Pipeline $PIPELINE_STATUS"
    exit 1
  fi
  exit 0
fi

# Poll until terminal state
log_step "Watching pipeline..."
while true; do
  sleep $POLL_INTERVAL

  PIPELINE_DATA=$(glab api "projects/$PROJECT_ID/pipelines/$PIPELINE_ID" 2>&1)
  PIPELINE_STATUS=$(echo "$PIPELINE_DATA" | jq -r '.status')

  log_info "Status: $PIPELINE_STATUS"

  if is_terminal_status "$PIPELINE_STATUS"; then
    if [ "$PIPELINE_STATUS" == "success" ]; then
      send_notification "✅ Pipeline Succeeded" "$CURRENT_BRANCH" "good"
      log_info "Pipeline succeeded!"
      echo "$PIPELINE_WEB_URL"
      exit 0
    else
      send_notification "❌ Pipeline $PIPELINE_STATUS" "$CURRENT_BRANCH" "bad"
      log_error "Pipeline $PIPELINE_STATUS: $PIPELINE_WEB_URL"
      exit 1
    fi
  fi
done
